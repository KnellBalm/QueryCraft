[
  {
    "problem_id": "2026-01-02_stream_sql_001",
    "difficulty": "easy",
    "topic": "funnel",
    "requester": "마케팅팀",
    "question": "2025년 10월 한 달 동안 'add_to_cart' 이벤트 후 'purchase' 이벤트로 전환된 사용자 수를 알려주세요.",
    "context": "이번 달 마케팅 캠페인의 효율성을 파악하기 위해 장바구니에 상품을 담은 후 실제 구매까지 이어진 사용자 수를 집계해야 합니다.",
    "submission_requirements": "결과는 'purchase_count'라는 컬럼으로 제공하며, 별도의 정렬은 필요 없습니다.",
    "answer_sql": "WITH AddToCart AS (\n    SELECT DISTINCT user_id, session_id\n    FROM stream_events\n    WHERE event_name = 'add_to_cart'\n      AND event_time BETWEEN '2025-10-01' AND '2025-10-31'\n),\nPurchased AS (\n    SELECT DISTINCT user_id, session_id\n    FROM stream_events\n    WHERE event_name = 'purchase'\n      AND event_time BETWEEN '2025-10-01' AND '2025-10-31'\n)\nSELECT COUNT(DISTINCT atc.user_id) AS purchase_count\nFROM AddToCart atc\nJOIN Purchased p ON atc.user_id = p.user_id AND atc.session_id = p.session_id;",
    "expected_columns": [
      "purchase_count"
    ],
    "sort_keys": [],
    "hint": "'add_to_cart'와 'purchase' 이벤트 모두 2025년 10월 데이터만 포함해야 합니다. 서로 다른 세션에서 발생한 'add_to_cart'와 'purchase'는 동일한 전환으로 보지 않습니다.",
    "date": "2026-01-02",
    "data_type": "stream",
    "xp_value": 3,
    "expected_result": [
      {
        "purchase_count": 7462
      }
    ],
    "expected_row_count": 1
  },
  {
    "problem_id": "2026-01-02_stream_sql_002",
    "difficulty": "easy",
    "topic": "revenue",
    "requester": "재무팀",
    "question": "2025년 11월 1일부터 2025년 11월 15일까지의 일별 총 매출액을 알려주세요.",
    "context": "특정 기간 동안의 매출 성과를 파악하여 재무 보고서에 포함해야 합니다.",
    "submission_requirements": "결과는 'date'와 'total_revenue' 컬럼으로 제공하며, 날짜 오름차순으로 정렬해야 합니다.",
    "answer_sql": "SELECT date, revenue AS total_revenue\nFROM stream_daily_metrics\nWHERE date BETWEEN '2025-11-01' AND '2025-11-15'\nORDER BY date ASC;",
    "expected_columns": [
      "date",
      "total_revenue"
    ],
    "sort_keys": [
      "date"
    ],
    "hint": "stream_daily_metrics 테이블에는 이미 일별 집계된 매출 정보가 포함되어 있습니다.",
    "date": "2026-01-02",
    "data_type": "stream",
    "xp_value": 3,
    "expected_result": [
      {
        "date": "2025-11-01",
        "total_revenue": 119649.0
      },
      {
        "date": "2025-11-02",
        "total_revenue": 72709.0
      },
      {
        "date": "2025-11-03",
        "total_revenue": 48019.0
      },
      {
        "date": "2025-11-04",
        "total_revenue": 127679.0
      },
      {
        "date": "2025-11-05",
        "total_revenue": 114884.0
      },
      {
        "date": "2025-11-06",
        "total_revenue": 129954.0
      },
      {
        "date": "2025-11-07",
        "total_revenue": 239110.0
      },
      {
        "date": "2025-11-08",
        "total_revenue": 36983.0
      },
      {
        "date": "2025-11-09",
        "total_revenue": 409120.0
      },
      {
        "date": "2025-11-10",
        "total_revenue": 46836.0
      },
      {
        "date": "2025-11-11",
        "total_revenue": 49322.0
      },
      {
        "date": "2025-11-12",
        "total_revenue": 133571.0
      },
      {
        "date": "2025-11-13",
        "total_revenue": 57553.0
      },
      {
        "date": "2025-11-14",
        "total_revenue": 382103.0
      },
      {
        "date": "2025-11-15",
        "total_revenue": 70848.0
      }
    ],
    "expected_row_count": 15
  },
  {
    "problem_id": "2026-01-02_stream_sql_003",
    "difficulty": "medium",
    "topic": "funnel",
    "requester": "마케팅팀",
    "question": "2025년 7월, 각 퍼널 단계('view_product', 'add_to_cart', 'checkout', 'purchase')별 사용자 수를 계산하고, 각 단계별 전환율(이전 단계 대비)을 계산해주세요. (첫 단계는 'view_product'로 가정)",
    "context": "사용자 여정의 각 단계별 이탈률을 분석하여 개선점을 찾고자 합니다. 특히 'view_product'부터 'purchase'까지의 전체 전환율을 파악하는 것이 중요합니다.",
    "submission_requirements": "결과는 'event_name', 'user_count', 'conversion_rate' 컬럼으로 제공해야 합니다. 'event_name'은 'view_product', 'add_to_cart', 'checkout', 'purchase' 순서로 정렬하고, 'conversion_rate'는 소수점 3자리까지 표시해주세요. 'view_product'의 전환율은 1.000으로 표시합니다.",
    "answer_sql": "WITH funnel_counts AS (\n    SELECT\n        'view_product' AS event_name,\n        COUNT(DISTINCT user_id) AS user_count\n    FROM stream_events\n    WHERE event_name = 'view_product'\n      AND event_time BETWEEN '2025-07-01' AND '2025-07-31'\n    UNION ALL\n    SELECT\n        'add_to_cart' AS event_name,\n        COUNT(DISTINCT user_id) AS user_count\n    FROM stream_events\n    WHERE event_name = 'add_to_cart'\n      AND event_time BETWEEN '2025-07-01' AND '2025-07-31'\n    UNION ALL\n    SELECT\n        'checkout' AS event_name,\n        COUNT(DISTINCT user_id) AS user_count\n    FROM stream_events\n    WHERE event_name = 'checkout'\n      AND event_time BETWEEN '2025-07-01' AND '2025-07-31'\n    UNION ALL\n    SELECT\n        'purchase' AS event_name,\n        COUNT(DISTINCT user_id) AS user_count\n    FROM stream_events\n    WHERE event_name = 'purchase'\n      AND event_time BETWEEN '2025-07-01' AND '2025-07-31'\n),\nranked_funnel AS (\n    SELECT\n        event_name,\n        user_count,\n        ROW_NUMBER() OVER (ORDER BY CASE event_name\n            WHEN 'view_product' THEN 1\n            WHEN 'add_to_cart' THEN 2\n            WHEN 'checkout' THEN 3\n            WHEN 'purchase' THEN 4\n        END) AS stage_order\n    FROM funnel_counts\n),\nprevious_stage_users AS (\n    SELECT\n        rf.event_name,\n        rf.user_count,\n        LAG(rf.user_count, 1, rf.user_count) OVER (ORDER BY rf.stage_order) AS prev_user_count\n    FROM ranked_funnel rf\n)\nSELECT\n    event_name,\n    user_count,\n    ROUND(CAST(user_count AS NUMERIC) / prev_user_count, 3) AS conversion_rate\nFROM previous_stage_users\nORDER BY stage_order;",
    "expected_columns": [
      "event_name",
      "user_count",
      "conversion_rate"
    ],
    "sort_keys": [
      "stage_order"
    ],
    "hint": "'LAG' 윈도우 함수를 사용하여 이전 단계의 사용자 수를 가져옵니다. 'view_product' 단계의 이전 사용자 수는 자기 자신으로 채워 전환율을 1로 만듭니다.",
    "date": "2026-01-02",
    "data_type": "stream",
    "xp_value": 5,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-02_stream_sql_004",
    "difficulty": "medium",
    "topic": "channel",
    "requester": "채널 분석팀",
    "question": "2025년 10월, 채널별 총 매출액과 총 구매 건수를 알려주세요.",
    "context": "각 채널의 성과를 비교 분석하여 효율적인 채널에 더 많은 예산을 할당하고자 합니다. 매출액과 구매 건수는 채널 성과를 측정하는 중요한 지표입니다.",
    "submission_requirements": "결과는 'channel', 'total_revenue', 'total_purchases' 컬럼으로 제공해야 합니다. 'total_revenue'는 소수점 둘째 자리까지 표시하고, 'total_purchases'는 구매 건수가 높은 순서대로 정렬해야 합니다.",
    "answer_sql": "WITH channel_metrics AS (\n    SELECT\n        se.channel,\n        COUNT(DISTINCT se.session_id) AS session_count, -- 세션 수를 기준으로 구매 건수 추정 (실제 구매 이벤트와 연결)\n        SUM(CASE WHEN se.event_name = 'purchase' THEN 1 ELSE 0 END) AS purchase_event_count\n    FROM stream_events se\n    WHERE se.event_time BETWEEN '2025-10-01' AND '2025-10-31'\n      AND se.event_name IN ('purchase') -- 실제 구매 이벤트만 고려\n    GROUP BY se.channel\n),\npurchase_data AS (\n    SELECT\n        sdm.date,\n        sdm.purchases,\n        sdm.revenue\n    FROM stream_daily_metrics sdm\n    WHERE sdm.date BETWEEN '2025-10-01' AND '2025-10-31'\n)\nSELECT\n    se.channel,\n    ROUND(SUM(pd.revenue) / COUNT(DISTINCT se.session_id) * COUNT(DISTINCT CASE WHEN se.event_name = 'purchase' THEN se.session_id ELSE NULL END), 2) AS total_revenue, -- 채널별 매출액 배분 (간단하게 세션 수 대비 비율로 추정)\n    SUM(CASE WHEN se.event_name = 'purchase' THEN 1 ELSE 0 END) AS total_purchases\nFROM stream_events se\nLEFT JOIN purchase_data pd ON se.event_time::DATE = pd.date\nWHERE se.event_time BETWEEN '2025-10-01' AND '2025-10-31'\nGROUP BY se.channel\nORDER BY total_purchases DESC;",
    "expected_columns": [
      "channel",
      "total_revenue",
      "total_purchases"
    ],
    "sort_keys": [
      "total_purchases"
    ],
    "hint": "채널별 매출액을 정확하게 분배하기 어렵기 때문에, 여기서는 일별 총 매출을 해당 일의 총 세션 수로 나누어 세션당 평균 매출을 구하고, 이를 채널별 구매 세션 수에 곱하는 방식으로 근사치를 계산합니다.",
    "date": "2026-01-02",
    "data_type": "stream",
    "xp_value": 5,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-02_stream_sql_005",
    "difficulty": "hard",
    "topic": "device",
    "requester": "데이터 엔지니어링팀",
    "question": "2025년 12월, 디바이스별 'purchase' 이벤트 전환율을 계산해주세요. 전환율은 ('purchase' 이벤트 발생 사용자 수) / ('visit' 이벤트 발생 사용자 수) 입니다. 'visit' 이벤트는 각 디바이스별로 처음 발생한 것으로 간주합니다.",
    "context": "사용자가 어떤 디바이스를 통해 우리 서비스를 이용하는지, 그리고 각 디바이스에서 구매 전환이 얼마나 잘 이루어지는지 파악하여 최적화 전략을 수립하고자 합니다.",
    "submission_requirements": "결과는 'device', 'purchase_users', 'visit_users', 'conversion_rate' 컬럼으로 제공해야 합니다. 'conversion_rate'는 소수점 4자리까지 표시하고, 'device' 이름으로 오름차순 정렬해야 합니다.",
    "answer_sql": "WITH DeviceVisits AS (\n    SELECT\n        user_id,\n        session_id,\n        device,\n        MIN(event_time) OVER (PARTITION BY user_id, device) AS first_visit_time\n    FROM stream_events\n    WHERE event_name = 'visit'\n      AND event_time BETWEEN '2025-12-01' AND '2025-12-31'\n),\nDevicePurchases AS (\n    SELECT DISTINCT\n        user_id,\n        session_id,\n        device\n    FROM stream_events\n    WHERE event_name = 'purchase'\n      AND event_time BETWEEN '2025-12-01' AND '2025-12-31'\n),\nPurchaseCountByDevice AS (\n    SELECT\n        dp.device,\n        COUNT(DISTINCT dp.user_id) AS purchase_users\n    FROM DevicePurchases dp\n    GROUP BY dp.device\n),\nVisitCountByDevice AS (\n    SELECT\n        dv.device,\n        COUNT(DISTINCT dv.user_id) AS visit_users\n    FROM DeviceVisits dv\n    WHERE dv.event_time = dv.first_visit_time\n    GROUP BY dv.device\n)\nSELECT\n    COALESCE(pc.device, vc.device) AS device,\n    COALESCE(pc.purchase_users, 0) AS purchase_users,\n    COALESCE(vc.visit_users, 0) AS visit_users,\n    CASE\n        WHEN COALESCE(vc.visit_users, 0) = 0 THEN 0.0000\n        ELSE ROUND(CAST(COALESCE(pc.purchase_users, 0) AS NUMERIC) / vc.visit_users, 4)\n    END AS conversion_rate\nFROM PurchaseCountByDevice pc\nFULL OUTER JOIN VisitCountByDevice vc ON pc.device = vc.device\nORDER BY device ASC;",
    "expected_columns": [
      "device",
      "purchase_users",
      "visit_users",
      "conversion_rate"
    ],
    "sort_keys": [
      "device"
    ],
    "hint": "'visit' 이벤트의 첫 발생 시간을 기준으로 각 디바이스에서의 첫 방문 사용자를 식별해야 합니다. 'FULL OUTER JOIN'을 사용하여 구매 또는 방문만 있는 디바이스도 포함시킵니다.",
    "date": "2026-01-02",
    "data_type": "stream",
    "xp_value": 8,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-02_stream_sql_006",
    "difficulty": "hard",
    "topic": "dau",
    "requester": "데이터 분석팀",
    "question": "2025년 11월 1일부터 2025년 11월 30일까지의 월간 활성 사용자 수(MAU)와 일별 활성 사용자 수(DAU)의 평균값을 계산해주세요.",
    "context": "월간 및 일별 사용자 활성도를 파악하여 서비스의 성장 추세와 안정성을 평가해야 합니다. MAU는 서비스의 전반적인 도달 범위를, 평균 DAU는 일상적인 사용 패턴을 나타냅니다.",
    "submission_requirements": "결과는 'metric_name' (MAU, Avg_DAU)과 'value' 컬럼으로 제공해야 합니다. 'value'는 소수점 둘째 자리까지 표시합니다.",
    "answer_sql": "WITH DailyActiveUsers AS (\n    SELECT\n        DATE_TRUNC('day', event_time)::DATE AS event_date,\n        COUNT(DISTINCT user_id) AS dau\n    FROM stream_events\n    WHERE event_time BETWEEN '2025-11-01' AND '2025-11-30'\n    GROUP BY event_date\n),\nMonthlyActiveUsers AS (\n    SELECT\n        COUNT(DISTINCT user_id) AS mau\n    FROM stream_events\n    WHERE event_time BETWEEN '2025-11-01' AND '2025-11-30'\n)\nSELECT 'MAU' AS metric_name, ROUND(CAST(mau AS NUMERIC), 2) AS value\nFROM MonthlyActiveUsers\nUNION ALL\nSELECT 'Avg_DAU' AS metric_name, ROUND(AVG(dau), 2) AS value\nFROM DailyActiveUsers;",
    "expected_columns": [
      "metric_name",
      "value"
    ],
    "sort_keys": [],
    "hint": "MAU는 해당 월 동안 한 번이라도 활동한 고유 사용자 수를 계산합니다. DAU는 각 날짜별로 고유 사용자 수를 계산하고, 그 평균을 구합니다. 'DATE_TRUNC' 함수를 사용하여 날짜만 추출합니다.",
    "date": "2026-01-02",
    "data_type": "stream",
    "xp_value": 8,
    "expected_result": [
      {
        "metric_name": "MAU",
        "value": 49714.0
      },
      {
        "metric_name": "Avg_DAU",
        "value": 7161.17
      }
    ],
    "expected_row_count": 2
  }
]