[
  {
    "problem_id": "startup_sql_001",
    "difficulty": "easy",
    "topic": "revenue",
    "requester": "경영진",
    "question": "안녕하세요. 11월 한 달간의 **일별 매출 추이**를 확인하고 싶습니다. 결과에는 **날짜(order_date)**, **일일 총 매출(daily_revenue)**, **일일 주문 건수(daily_order_count)** 컬럼이 포함되어야 합니다. **날짜 기준 오름차순**으로 정렬 부탁드립니다.",
    "context": "월간 실적 보고를 앞두고, 11월 매출의 주요 동향을 파악하여 프로모션 효과 및 주말/평일 패턴을 확인하고자 합니다. 이를 통해 12월 매출 전략 수립에 참고할 예정입니다.",
    "submission_requirements": "결과는 'order_date' 컬럼을 기준으로 오름차순 정렬해야 합니다. 'order_date'는 'YYYY-MM-DD' 형식이어야 합니다. 'daily_revenue'와 'daily_order_count'는 정수로 표현해주세요.",
    "answer_sql": "SELECT\n  DATE_TRUNC('day', order_time)::DATE AS order_date,\n  SUM(amount)::INT AS daily_revenue,\n  COUNT(order_id)::INT AS daily_order_count\nFROM pa_orders\nWHERE order_time >= '2025-11-01' AND order_time < '2025-12-01'\nGROUP BY order_date\nORDER BY order_date ASC;",
    "expected_description": "2025년 11월 1일부터 11월 30일까지 각 날짜별로 발생한 총 매출과 총 주문 건수를 나타내는 테이블입니다.",
    "expected_columns": [
      "order_date",
      "daily_revenue",
      "daily_order_count"
    ],
    "sort_keys": [
      "order_date"
    ],
    "hint": "DATE_TRUNC 함수를 사용하여 'order_time'을 일별로 그룹핑하고, SUM과 COUNT 집계 함수를 사용하세요. WHERE 절로 11월 기간을 정확히 필터링해야 합니다.",
    "expected_meta": {
      "row_count": 30,
      "columns": [
        {
          "name": "order_date",
          "type": "date"
        },
        {
          "name": "daily_revenue",
          "type": "integer"
        },
        {
          "name": "daily_order_count",
          "type": "integer"
        }
      ],
      "grading_table": "grading.expected_startup_sql_001"
    }
  },
  {
    "problem_id": "startup_sql_002",
    "difficulty": "easy",
    "topic": "marketing",
    "requester": "마케팅팀",
    "question": "각 **마케팅 채널(channel)별 총 가입자 수**를 확인하고 싶습니다. 결과에는 **채널명(channel)** 과 **가입자 수(user_count)** 컬럼이 필요하며, **가입자 수가 많은 순서**로 정렬해주세요.",
    "context": "다음 분기 마케팅 예산 분배를 위해 채널별 성과를 측정해야 합니다. 어떤 채널에서 가장 많은 사용자를 확보했는지 파악하는 것이 첫 단계입니다.",
    "submission_requirements": "결과는 'user_count' 컬럼 기준으로 내림차순 정렬해야 합니다. 'user_count'는 정수여야 합니다.",
    "answer_sql": "SELECT\n  channel,\n  COUNT(user_id) AS user_count\nFROM pa_users\nGROUP BY channel\nORDER BY user_count DESC;",
    "expected_description": "데이터에 존재하는 모든 마케팅 채널 각각에 대해 해당 채널을 통해 가입한 총 사용자 수를 집계한 테이블입니다.",
    "expected_columns": [
      "channel",
      "user_count"
    ],
    "sort_keys": [
      "user_count"
    ],
    "hint": "pa_users 테이블에서 'channel' 컬럼으로 GROUP BY 하고, COUNT 함수로 user_id의 개수를 세어보세요. ORDER BY ... DESC를 사용해 정렬합니다.",
    "expected_meta": {
      "row_count": 3,
      "columns": [
        {
          "name": "channel",
          "type": "text"
        },
        {
          "name": "user_count",
          "type": "bigint"
        }
      ],
      "grading_table": "grading.expected_startup_sql_002"
    }
  },
  {
    "problem_id": "startup_sql_003",
    "difficulty": "medium",
    "topic": "funnel",
    "requester": "그로스팀",
    "question": "2025년 11월 가입자의 **구매 전환 퍼널**을 분석하고 싶습니다. **각 단계(funnel_step)**, **해당 단계를 완료한 유저 수(user_count)**, **이전 단계 대비 전환율(conversion_rate_from_previous)** 컬럼을 추출해주세요. 퍼널 단계는 'view' -> 'add_to_cart' -> 'purchase' 순서입니다.",
    "context": "사용자들이 어떤 단계에서 가장 많이 이탈하는지, 즉 퍼널의 병목 구간을 찾기 위함입니다. 이를 통해 UI/UX 개선 우선순위를 정할 수 있습니다.",
    "submission_requirements": "결과는 'funnel_step' 순서대로 정렬되어야 합니다. 'conversion_rate_from_previous'는 소수점 둘째 자리까지 반올림하여 퍼센티지(%)로 표시해주세요. 첫 단계의 전환율은 100.00으로 표시합니다.",
    "answer_sql": "WITH target_users AS (\n  SELECT user_id\n  FROM pa_users\n  WHERE signup_at >= '2025-11-01' AND signup_at < '2025-12-01'\n),\nfunnel_counts AS (\n  SELECT\n    COUNT(DISTINCT CASE WHEN e.event_name = 'view' THEN e.user_id END) AS view_users,\n    COUNT(DISTINCT CASE WHEN e.event_name = 'add_to_cart' THEN e.user_id END) AS add_to_cart_users,\n    COUNT(DISTINCT CASE WHEN e.event_name = 'purchase' THEN e.user_id END) AS purchase_users\n  FROM pa_events e\n  JOIN target_users tu ON e.user_id = tu.user_id\n)\nSELECT\n  '1_view' AS funnel_step,\n  view_users AS user_count,\n  100.00 AS conversion_rate_from_previous\nFROM funnel_counts\nUNION ALL\nSELECT\n  '2_add_to_cart' AS funnel_step,\n  add_to_cart_users AS user_count,\n  ROUND(add_to_cart_users * 100.0 / NULLIF(view_users, 0), 2)\nFROM funnel_counts\nUNION ALL\nSELECT\n  '3_purchase' AS funnel_step,\n  purchase_users AS user_count,\n  ROUND(purchase_users * 100.0 / NULLIF(add_to_cart_users, 0), 2)\nFROM funnel_counts;",
    "expected_description": "2025년 11월에 가입한 사용자들이 'view', 'add_to_cart', 'purchase' 이벤트를 각각 몇 명이나 발생시켰는지, 그리고 각 단계로의 전환율이 얼마인지를 보여주는 퍼널 분석 테이블입니다.",
    "expected_columns": [
      "funnel_step",
      "user_count",
      "conversion_rate_from_previous"
    ],
    "sort_keys": [
      "funnel_step"
    ],
    "hint": "WITH 절을 사용하여 11월 가입자를 먼저 선별하세요. 그 다음, CASE 문과 COUNT(DISTINCT ...)를 활용하여 각 이벤트별 유저 수를 한 번에 계산합니다. 마지막으로 UNION ALL을 사용하여 각 단계의 결과와 전환율을 결합합니다. 0으로 나누기 오류를 방지하기 위해 NULLIF 함수를 사용하세요.",
    "expected_meta": {
      "row_count": 3,
      "columns": [
        {
          "name": "funnel_step",
          "type": "text"
        },
        {
          "name": "user_count",
          "type": "bigint"
        },
        {
          "name": "conversion_rate_from_previous",
          "type": "numeric"
        }
      ],
      "grading_table": "grading.expected_startup_sql_003"
    }
  },
  {
    "problem_id": "startup_sql_004",
    "difficulty": "medium",
    "topic": "retention",
    "requester": "PM팀",
    "question": "**2025년 11월 첫째 주(11/1~11/7) 가입자**의 **Day 1, Day 3, Day 7 리텐션**을 계산해주세요. 결과에는 **코호트 기간(cohort_period)**, **총 가입자 수(cohort_size)**, 그리고 각 리텐션 비율(**day_1_retention**, **day_3_retention**, **day_7_retention**)이 포함되어야 합니다.",
    "context": "최근 배포한 신규 기능이 초기 사용자 유지에 긍정적인 영향을 미치는지 확인하고 싶습니다. 단기 리텐션 지표는 제품의 첫인상과 가치를 빠르게 판단하는 데 도움이 됩니다.",
    "submission_requirements": "리텐션 비율은 소수점 둘째 자리까지 반올림한 퍼센티지(%) 값으로 나타내 주세요. 코호트 기간은 'YYYY-MM-DD to YYYY-MM-DD' 형식의 문자열로 표시합니다.",
    "answer_sql": "WITH cohort_users AS (\n  SELECT\n    user_id,\n    DATE(signup_at) AS signup_date\n  FROM pa_users\n  WHERE signup_at >= '2025-11-01' AND signup_at < '2025-11-08'\n),\nsubsequent_activity AS (\n  SELECT DISTINCT\n    s.user_id,\n    DATE(s.started_at) - cu.signup_date AS days_after_signup\n  FROM pa_sessions s\n  JOIN cohort_users cu ON s.user_id = cu.user_id\n  WHERE DATE(s.started_at) > cu.signup_date\n)\nSELECT\n  '2025-11-01 to 2025-11-07' AS cohort_period,\n  (SELECT COUNT(*) FROM cohort_users) AS cohort_size,\n  ROUND(COUNT(DISTINCT CASE WHEN days_after_signup = 1 THEN user_id END) * 100.0 / NULLIF((SELECT COUNT(*) FROM cohort_users), 0), 2) AS day_1_retention,\n  ROUND(COUNT(DISTINCT CASE WHEN days_after_signup = 3 THEN user_id END) * 100.0 / NULLIF((SELECT COUNT(*) FROM cohort_users), 0), 2) AS day_3_retention,\n  ROUND(COUNT(DISTINCT CASE WHEN days_after_signup = 7 THEN user_id END) * 100.0 / NULLIF((SELECT COUNT(*) FROM cohort_users), 0), 2) AS day_7_retention\nFROM subsequent_activity;",
    "expected_description": "2025년 11월 1일부터 7일까지 가입한 사용자 코호트의 규모와, 이들이 가입 후 1일차, 3일차, 7일차에 다시 방문했는지의 비율을 계산한 리텐션 테이블입니다.",
    "expected_columns": [
      "cohort_period",
      "cohort_size",
      "day_1_retention",
      "day_3_retention",
      "day_7_retention"
    ],
    "sort_keys": [],
    "hint": "두 개의 CTE를 사용하세요. 첫 번째는 특정 기간의 가입자(코호트)를 정의하고, 두 번째는 이들의 후속 활동(세션 시작)을 추적합니다. 두 번째 CTE에서 가입일과 활동일의 차이를 계산하여 '가입 후 N일'을 구하는 것이 핵심입니다. 최종 SELECT 문에서 CASE 문을 사용하여 각 리텐션 날짜에 해당하는 유저 수를 계산합니다.",
    "expected_meta": {
      "row_count": 1,
      "columns": [
        {
          "name": "cohort_period",
          "type": "text"
        },
        {
          "name": "cohort_size",
          "type": "bigint"
        },
        {
          "name": "day_1_retention",
          "type": "numeric"
        },
        {
          "name": "day_3_retention",
          "type": "numeric"
        },
        {
          "name": "day_7_retention",
          "type": "numeric"
        }
      ],
      "grading_table": "grading.expected_startup_sql_004"
    }
  },
  {
    "problem_id": "startup_sql_005",
    "difficulty": "hard",
    "topic": "cohort",
    "requester": "경영진",
    "question": "**2025년 10월 가입자 코호트**의 **월별 누적 LTV(고객 생애 가치)**를 분석해주세요. 결과에는 **가입 후 경과 개월(month_after_signup)**, **해당 월의 ARPU(monthly_arpu)**, **해당 월까지의 누적 LTV(cumulative_ltv)** 컬럼이 포함되어야 합니다. **경과 개월 순으로 오름차순 정렬**해주세요.",
    "context": "신규 사용자의 가치를 시간 흐름에 따라 파악하여 마케팅 채널별 CAC(고객 획득 비용) 대비 효율성을 평가하고자 합니다. LTV 분석은 장기적인 비즈니스 건전성을 예측하는 데 필수적입니다.",
    "submission_requirements": "'month_after_signup'은 가입월을 0으로 시작하는 정수입니다. 'monthly_arpu'와 'cumulative_ltv'는 소수점 둘째 자리까지 반올림해주세요.",
    "answer_sql": "WITH cohort AS (\n  SELECT\n    user_id,\n    DATE_TRUNC('month', signup_at) AS cohort_month\n  FROM pa_users\n  WHERE signup_at >= '2025-10-24' AND signup_at < '2025-11-01'\n),\ncohort_size AS (\n  SELECT COUNT(DISTINCT user_id) AS total_users FROM cohort\n),\nrevenue_by_month AS (\n  SELECT\n    (DATE_PART('year', o.order_time) - DATE_PART('year', c.cohort_month)) * 12 +\n    (DATE_PART('month', o.order_time) - DATE_PART('month', c.cohort_month)) AS month_after_signup,\n    SUM(o.amount) AS monthly_revenue\n  FROM pa_orders o\n  JOIN cohort c ON o.user_id = c.user_id\n  GROUP BY 1\n)\nSELECT\n  r.month_after_signup,\n  ROUND(r.monthly_revenue::DECIMAL / s.total_users, 2) AS monthly_arpu,\n  ROUND(SUM(r.monthly_revenue::DECIMAL) OVER (ORDER BY r.month_after_signup) / s.total_users, 2) AS cumulative_ltv\nFROM revenue_by_month r, cohort_size s\nORDER BY r.month_after_signup;",
    "expected_description": "2025년 10월에 가입한 사용자 코호트가 가입 이후 매월 사용자당 평균 얼마의 매출을 발생시켰는지(monthly_arpu), 그리고 시간이 지남에 따라 1인당 누적 매출(cumulative_ltv)이 어떻게 증가하는지를 보여주는 테이블입니다.",
    "expected_columns": [
      "month_after_signup",
      "monthly_arpu",
      "cumulative_ltv"
    ],
    "sort_keys": [
      "month_after_signup"
    ],
    "hint": "가입일과 주문일의 월 차이를 계산하여 'month_after_signup'을 구하는 것이 핵심입니다. Postgres의 DATE_PART 함수를 사용하면 유용합니다. 월별 매출을 집계한 후, 윈도우 함수 SUM(...) OVER (ORDER BY ...)를 사용하여 누적 합계를 계산하고, 이를 전체 코호트 사이즈로 나누어 LTV를 구합니다.",
    "expected_meta": {
      "row_count": 3,
      "columns": [
        {
          "name": "month_after_signup",
          "type": "double precision"
        },
        {
          "name": "monthly_arpu",
          "type": "numeric"
        },
        {
          "name": "cumulative_ltv",
          "type": "numeric"
        }
      ],
      "grading_table": "grading.expected_startup_sql_005"
    }
  },
  {
    "problem_id": "startup_sql_006",
    "difficulty": "hard",
    "topic": "segmentation",
    "requester": "마케팅팀",
    "question": "**2025년 11월 가입자** 중, **'google' 채널과 'facebook' 채널** 사용자의 구매 퍼널 성과를 비교 분석해주세요. 결과에는 **채널명(channel)**, **최초 'view' 이벤트 발생 유저 수(view_users)**, **'view'에서 'add_to_cart' 전환율(view_to_cart_cr)**, **'add_to_cart'에서 'purchase' 전환율(cart_to_purchase_cr)**, 그리고 **최종 구매 전환율('view' to 'purchase', overall_cr)**이 포함되어야 합니다.",
    "context": "주요 광고 채널인 구글과 페이스북의 성과를 정량적으로 비교하여, 어떤 채널이 더 구매 의사가 높은 사용자를 데려오는지 확인하고 싶습니다. 이 분석 결과는 향후 광고 예산 재분배 및 채널별 메시지 최적화에 활용될 예정입니다.",
    "submission_requirements": "결과는 'channel' 컬럼 기준으로 오름차순 정렬해주세요. 모든 전환율(CR)은 소수점 둘째 자리까지 반올림한 퍼센티지(%) 값으로 표시해야 합니다.",
    "answer_sql": "WITH target_users AS (\n  SELECT user_id, channel\n  FROM pa_users\n  WHERE signup_at >= '2025-11-01' AND signup_at < '2025-12-01'\n    AND channel IN ('google', 'facebook')\n),\nchannel_funnel_counts AS (\n  SELECT\n    tu.channel,\n    COUNT(DISTINCT CASE WHEN e.event_name = 'view' THEN e.user_id END) AS view_users,\n    COUNT(DISTINCT CASE WHEN e.event_name = 'add_to_cart' THEN e.user_id END) AS add_to_cart_users,\n    COUNT(DISTINCT CASE WHEN e.event_name = 'purchase' THEN e.user_id END) AS purchase_users\n  FROM pa_events e\n  RIGHT JOIN target_users tu ON e.user_id = tu.user_id\n  GROUP BY tu.channel\n)\nSELECT\n  channel,\n  view_users,\n  ROUND(add_to_cart_users * 100.0 / NULLIF(view_users, 0), 2) AS view_to_cart_cr,\n  ROUND(purchase_users * 100.0 / NULLIF(add_to_cart_users, 0), 2) AS cart_to_purchase_cr,\n  ROUND(purchase_users * 100.0 / NULLIF(view_users, 0), 2) AS overall_cr\nFROM channel_funnel_counts\nORDER BY channel;",
    "expected_description": "2025년 11월에 'google'과 'facebook' 채널을 통해 가입한 사용자 그룹을 대상으로, 각 그룹이 구매 퍼널의 각 단계를 얼마나 잘 통과하는지를 비교하는 테이블입니다. 채널별로 전환율을 비교하여 효율성을 평가할 수 있습니다.",
    "expected_columns": [
      "channel",
      "view_users",
      "view_to_cart_cr",
      "cart_to_purchase_cr",
      "overall_cr"
    ],
    "sort_keys": [
      "channel"
    ],
    "hint": "먼저 WITH 절을 사용해 11월에 특정 채널로 가입한 사용자 그룹을 정의합니다. 그 다음 CTE에서 이 사용자 그룹을 기준으로, 각 채널별로 'view', 'add_to_cart', 'purchase' 이벤트를 발생시킨 유니크 유저 수를 집계합니다. RIGHT JOIN을 사용하면 이벤트가 없는 유저도 계산에 포함될 수 있습니다. 마지막으로, 집계된 유저 수를 바탕으로 각 단계별 전환율을 계산합니다. 0으로 나누기 오류에 주의하세요.",
    "expected_meta": {
      "row_count": 0,
      "columns": [
        {
          "name": "channel",
          "type": "text"
        },
        {
          "name": "view_users",
          "type": "bigint"
        },
        {
          "name": "view_to_cart_cr",
          "type": "numeric"
        },
        {
          "name": "cart_to_purchase_cr",
          "type": "numeric"
        },
        {
          "name": "overall_cr",
          "type": "numeric"
        }
      ],
      "grading_table": "grading.expected_startup_sql_006"
    }
  }
]