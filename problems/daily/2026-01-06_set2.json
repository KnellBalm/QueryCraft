[
  {
    "problem_id": "2026-01-06_ecommerce_sql_001_set2",
    "difficulty": "easy",
    "topic": "revenue",
    "requester": "마케팅팀",
    "question": "각 채널별로 2025년 11월 한 달간의 총 거래액(GMV)과 평균 주문 금액(AOV)을 비교하고 싶습니다. 각 채널별 상세한 성과를 파악하여 다음 달 마케팅 예산 할당에 참고하고자 합니다.",
    "context": "마케팅팀에서는 각 광고 채널의 효율성을 측정하고, 효과적인 채널에 더 많은 예산을 투입하는 것이 중요합니다. 이를 위해 특정 기간 동안 각 채널의 매출 기여도를 파악해야 합니다.",
    "submission_requirements": "결과는 총 거래액(GMV) 기준으로 내림차순 정렬하며, 평균 주문 금액(AOV)은 소수점 둘째 자리까지 반올림하여 표시해주세요. 분석 기간은 2025-11-01부터 2025-11-30까지입니다.",
    "answer_sql": "SELECT\n    pu.channel,\n    SUM(po.amount) AS total_gmv,\n    AVG(po.amount) AS average_order_value\nFROM\n    pa_orders po\nJOIN\n    pa_users pu ON po.user_id = pu.user_id\nWHERE\n    po.order_time >= '2025-11-01 00:00:00'\n    AND po.order_time < '2025-12-01 00:00:00'\nGROUP BY\n    pu.channel\nORDER BY\n    total_gmv DESC;",
    "expected_description": "각 마케팅 채널별 총 거래액(GMV)과 평균 주문 금액(AOV)을 보여주는 테이블입니다.",
    "expected_columns": [
      "channel",
      "total_gmv",
      "average_order_value"
    ],
    "sort_keys": [
      "total_gmv DESC"
    ],
    "hint": "pa_orders 테이블과 pa_users 테이블을 user_id로 JOIN하고, order_time을 기준으로 기간을 필터링한 뒤, channel 별로 GROUP BY하여 SUM과 AVG 함수를 사용하세요.",
    "date": "2026-01-06",
    "set_index": 2,
    "xp_value": 3,
    "expected_result": [
      {
        "channel": "referral",
        "total_gmv": 764129,
        "average_order_value": 24649.322580645163
      },
      {
        "channel": "organic",
        "total_gmv": 445432,
        "average_order_value": 19366.608695652176
      },
      {
        "channel": "ad",
        "total_gmv": 436143,
        "average_order_value": 31153.071428571428
      },
      {
        "channel": "web",
        "total_gmv": 317658,
        "average_order_value": 21177.2
      }
    ],
    "expected_row_count": 4
  },
  {
    "problem_id": "2026-01-06_ecommerce_sql_002_set2",
    "difficulty": "easy",
    "topic": "funnel",
    "requester": "PM팀",
    "question": "2025년 12월에 'view_product' 이벤트를 경험한 사용자 중 'purchase' 이벤트까지 완료한 사용자의 비율을 알고 싶습니다. 이는 상품 상세 페이지가 실제 구매로 얼마나 잘 이어지는지 파악하는 데 중요합니다.",
    "context": "PM팀에서는 신규 상품 상세 페이지의 효과를 측정하고 개선점을 찾기 위해 전환율 분석을 수행합니다. 'view_product'부터 'purchase'까지 이어지는 퍼널의 중간 전환율을 이해하는 것이 핵심입니다.",
    "submission_requirements": "결과는 'view_product_count', 'purchase_count', 'conversion_rate' 컬럼으로 제공하며, 'conversion_rate'는 소수점 넷째 자리에서 반올림하여 백분율(%)로 표시해주세요. 분석 대상 기간은 2025-12-01부터 2025-12-31까지입니다.",
    "answer_sql": "WITH PurchaseEvents AS (\n    SELECT\n        user_id,\n        MIN(event_time) as purchase_time\n    FROM pa_events\n    WHERE event_name = 'purchase'\n    GROUP BY user_id\n),\nViewProductEvents AS (\n    SELECT\n        user_id,\n        MIN(event_time) as view_product_time\n    FROM pa_events\n    WHERE event_name = 'view_product'\n    GROUP BY user_id\n)\nSELECT\n    COUNT(DISTINCT vp.user_id) AS view_product_count,\n    COUNT(DISTINCT pu.user_id) AS purchase_count,\n    CASE\n        WHEN COUNT(DISTINCT vp.user_id) = 0 THEN 0.00\n        ELSE ROUND(CAST(COUNT(DISTINCT pu.user_id) AS DECIMAL) * 100 / COUNT(DISTINCT vp.user_id), 2)\n    END AS conversion_rate\nFROM\n    ViewProductEvents vp\nLEFT JOIN\n    PurchaseEvents pu ON vp.user_id = pu.user_id AND vp.view_product_time < pu.purchase_time\nWHERE\n    vp.view_product_time >= '2025-12-01 00:00:00'\n    AND vp.view_product_time < '2025-12-31 23:59:59';",
    "expected_description": "'view_product' 이벤트를 경험한 총 사용자 수, 이 중 'purchase'까지 완료한 사용자 수, 그리고 이 둘 간의 전환율(%)을 보여줍니다.",
    "expected_columns": [
      "view_product_count",
      "purchase_count",
      "conversion_rate"
    ],
    "sort_keys": [],
    "hint": "먼저 'purchase' 이벤트를 완료한 사용자와 'view_product' 이벤트를 경험한 사용자를 각각 그룹화하여 최소 이벤트 시간을 구합니다. 이후, 'view_product' 이벤트를 경험한 사용자 중 'purchase'까지 완료한 사용자를 LEFT JOIN으로 연결하여 전환율을 계산합니다. NULLIF를 사용하여 0으로 나누는 것을 방지하세요.",
    "date": "2026-01-06",
    "set_index": 2,
    "xp_value": 3,
    "expected_result": [
      {
        "view_product_count": 23426.0,
        "purchase_count": 231.0,
        "conversion_rate": 0.99
      }
    ],
    "expected_row_count": 1
  },
  {
    "problem_id": "2026-01-06_ecommerce_sql_003_set2",
    "difficulty": "medium",
    "topic": "funnel",
    "requester": "CX팀",
    "question": "장바구니에 상품을 담은(add_to_cart) 후, 실제로 구매(purchase)하지 않고 세션이 종료된 사용자들의 행동 패턴을 파악하고 싶습니다. 2025년 10월 30일부터 2025년 12월 29일까지의 데이터를 분석하여, 장바구니 이탈 직전 사용자들이 주로 어떤 이벤트를 수행했는지 알려주세요.",
    "context": "CX팀에서는 고객 경험 개선을 목표로 합니다. 장바구니 이탈은 명확한 이탈 신호이므로, 이탈 직전의 사용자 행동을 이해하면 이탈을 방지할 수 있는 전략을 수립하는 데 도움이 됩니다.",
    "submission_requirements": "결과는 각 'event_name'별 발생 횟수를 기준으로 내림차순 정렬해주세요. 분석 대상 기간은 2025-10-30부터 2025-12-29까지입니다. 'add_to_cart' 이벤트 이후 'purchase' 이벤트가 발생하지 않은 세션에 한정합니다.",
    "answer_sql": "WITH AddToCartSessions AS (\n    SELECT\n        session_id,\n        user_id,\n        MAX(event_time) AS last_add_to_cart_time\n    FROM pa_events\n    WHERE event_name = 'add_to_cart'\n    AND event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n    GROUP BY session_id, user_id\n),\nPurchasedSessions AS (\n    SELECT\n        session_id,\n        user_id\n    FROM pa_events\n    WHERE event_name = 'purchase'\n    AND event_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n    GROUP BY session_id, user_id\n),\nAbandonedCartEvents AS (\n    SELECT\n        pe.session_id,\n        pe.event_name,\n        pe.event_time\n    FROM pa_events pe\n    JOIN AddToCartSessions acs ON pe.session_id = acs.session_id AND pe.user_id = acs.user_id\n    LEFT JOIN PurchasedSessions ps ON acs.session_id = ps.session_id AND acs.user_id = ps.user_id\n    WHERE ps.session_id IS NULL -- 구매가 발생하지 않은 세션\n    AND pe.event_time >= acs.last_add_to_cart_time -- 장바구니 담기 이후 이벤트\n    AND pe.event_time <= (SELECT MAX(started_at) FROM pa_sessions WHERE session_id = pe.session_id) -- 세션 종료 시간까지\n)\nSELECT\n    event_name,\n    COUNT(*) AS event_count\nFROM\n    AbandonedCartEvents\nGROUP BY\n    event_name\nORDER BY\n    event_count DESC;",
    "expected_description": "장바구니에 상품을 담은 후 구매하지 않고 이탈한 세션에서 발생한 이벤트들의 발생 횟수를 보여줍니다. 이탈 전 사용자 행동 패턴 파악에 활용됩니다.",
    "expected_columns": [
      "event_name",
      "event_count"
    ],
    "sort_keys": [
      "event_count DESC"
    ],
    "hint": "먼저 장바구니에 담은 세션과 구매한 세션을 분리합니다. 이후, 장바구니에 담았지만 구매하지 않은 세션에서 발생한 이벤트들을 추출하고, 각 이벤트별로 발생 횟수를 집계합니다. 세션의 종료 시간을 파악하는 것이 중요합니다.",
    "date": "2026-01-06",
    "set_index": 2,
    "xp_value": 5,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-06_ecommerce_sql_004_set2",
    "difficulty": "medium",
    "topic": "retention",
    "requester": "그로스팀",
    "question": "2025년 11월에 첫 구매를 완료한 사용자(activation)가 2025년 12월에도 재구매를 한 비율을 알고 싶습니다. 각 사용자별 첫 구매 시점을 기준으로 다음 달 재구매율을 추적하고 싶습니다.",
    "context": "그로스팀에서는 고객의 장기적인 가치를 높이는 데 집중합니다. 첫 구매 이후 고객들이 얼마나 우리 플랫폼에 다시 돌아와 구매하는지를 파악하는 것은 고객 충성도를 측정하고 Retention 전략을 수립하는 데 필수적입니다.",
    "submission_requirements": "결과는 'first_purchase_month' (YYYY-MM 형식)과 'repeat_purchase_rate' 컬럼으로 제공합니다. 'repeat_purchase_rate'는 소수점 넷째 자리에서 반올림하여 백분율(%)로 표시해주세요. 분석 대상 기간은 2025-11-01부터 2025-12-31까지입니다.",
    "answer_sql": "WITH FirstPurchase AS (\n    SELECT\n        user_id,\n        MIN(order_time) AS first_purchase_time,\n        DATE_TRUNC('month', MIN(order_time)) AS first_purchase_month\n    FROM pa_orders\n    WHERE order_time BETWEEN '2025-11-01 00:00:00' AND '2025-12-31 23:59:59'\n    GROUP BY user_id\n),\nSecondPurchase AS (\n    SELECT\n        op.user_id,\n        MIN(op.order_time) AS second_purchase_time\n    FROM pa_orders op\n    JOIN FirstPurchase fp ON op.user_id = fp.user_id\n    WHERE op.order_time > fp.first_purchase_time -- 첫 구매 이후의 구매\n    AND op.order_time BETWEEN '2025-11-01 00:00:00' AND '2025-12-31 23:59:59'\n    GROUP BY op.user_id, fp.first_purchase_month\n)\nSELECT\n    DATE_TRUNC('month', fp.first_purchase_time)::DATE AS first_purchase_month,\n    ROUND(CAST(COUNT(DISTINCT sp.user_id) AS DECIMAL) * 100 / COUNT(DISTINCT fp.user_id), 2) AS repeat_purchase_rate\nFROM\n    FirstPurchase fp\nLEFT JOIN\n    SecondPurchase sp ON fp.user_id = sp.user_id\nWHERE\n    DATE_TRUNC('month', fp.first_purchase_time) = '2025-11-01'\nGROUP BY\n    first_purchase_month\nORDER BY\n    first_purchase_month;",
    "expected_description": "2025년 11월에 첫 구매를 한 사용자를 기준으로, 해당 월에 다음 달(2025년 12월)에 재구매한 사용자 비율을 보여줍니다.",
    "expected_columns": [
      "first_purchase_month",
      "repeat_purchase_rate"
    ],
    "sort_keys": [
      "first_purchase_month"
    ],
    "hint": "먼저 각 사용자의 첫 구매 시점과 첫 구매 월을 파악합니다. 그 후, 첫 구매 이후의 두 번째 구매 시점을 찾습니다. 첫 구매 월이 2025년 11월인 사용자를 필터링하여, 이 중 2025년 12월에 재구매한 비율을 계산합니다. CASE WHEN NULLIF 등을 활용하여 0으로 나누는 경우를 방지하세요.",
    "date": "2026-01-06",
    "set_index": 2,
    "xp_value": 5,
    "expected_result": [],
    "expected_row_count": 0
  },
  {
    "problem_id": "2026-01-06_ecommerce_sql_005_set2",
    "difficulty": "hard",
    "topic": "funnel",
    "requester": "PM팀",
    "question": "2025년 12월 한 달 동안 'compare_product' 이벤트가 발생한 세션들을 분석하여, 사용자들이 특정 상품을 비교한 후 실제로 어떤 행동(event_name)을 취하는지 파악하고 싶습니다. 비교 후 이탈하는 비율이 높은지, 아니면 구매로 이어지는 비율이 높은지 확인하고 싶습니다.",
    "context": "PM팀에서는 상품 비교 기능의 활용도를 높이고, 이 기능이 실제 구매 전환에 어떤 영향을 미치는지 이해해야 합니다. 이를 통해 비교 기능의 개선 방향을 설정하거나, 비교 후 사용자를 유도하는 새로운 방안을 모색할 수 있습니다.",
    "submission_requirements": "결과는 'event_name'과 해당 이벤트의 'count'를 보여줍니다. 'compare_product' 이벤트가 발생한 세션 내에서, 'compare_product' 이벤트 이후 발생한 첫 번째 이벤트의 종류별 빈도를 계산해주세요. 분석 기간은 2025-12-01부터 2025-12-31까지입니다.",
    "answer_sql": "WITH CompareProductSessions AS (\n    SELECT DISTINCT session_id, user_id\n    FROM pa_events\n    WHERE event_name = 'compare_product'\n    AND event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n),\nNextEventAfterCompare AS (\n    SELECT\n        pe.session_id,\n        pe.user_id,\n        pe.event_name AS next_event_name,\n        ROW_NUMBER() OVER(PARTITION BY pe.session_id ORDER BY pe.event_time ASC) as rn\n    FROM pa_events pe\n    JOIN CompareProductSessions cps ON pe.session_id = cps.session_id AND pe.user_id = cps.user_id\n    WHERE pe.event_time > (\n        SELECT MIN(event_time)\n        FROM pa_events\n        WHERE session_id = pe.session_id\n        AND event_name = 'compare_product'\n    )\n    AND pe.event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n)\nSELECT\n    next_event_name,\n    COUNT(*) AS event_count\nFROM\n    NextEventAfterCompare\nWHERE rn = 1\nGROUP BY\n    next_event_name\nORDER BY\n    event_count DESC;",
    "expected_description": "상품 비교 이벤트가 발생한 세션에서, 비교 직후 발생하는 첫 번째 이벤트의 종류별 빈도를 보여줍니다. 이를 통해 사용자의 다음 행동 패턴을 파악할 수 있습니다.",
    "expected_columns": [
      "next_event_name",
      "event_count"
    ],
    "sort_keys": [
      "event_count DESC"
    ],
    "hint": "먼저 'compare_product' 이벤트가 발생한 세션 ID들을 추출합니다. 그 다음, 각 세션에서 'compare_product' 이벤트 발생 시점 이후 가장 먼저 발생한 이벤트의 종류를 ROW_NUMBER() 함수를 사용하여 파악합니다. 마지막으로, 이 이벤트들의 종류별 빈도를 집계합니다. 분석 기간 필터링을 잊지 마세요.",
    "date": "2026-01-06",
    "set_index": 2,
    "xp_value": 8,
    "expected_result": [
      {
        "next_event_name": "view_product",
        "event_count": 7046
      },
      {
        "next_event_name": "bundle_view",
        "event_count": 1067
      },
      {
        "next_event_name": "add_to_cart",
        "event_count": 1021
      },
      {
        "next_event_name": "wishlist_add",
        "event_count": 753
      },
      {
        "next_event_name": "refund_request",
        "event_count": 61
      }
    ],
    "expected_row_count": 5
  },
  {
    "problem_id": "2026-01-06_ecommerce_sql_006_set2",
    "difficulty": "hard",
    "topic": "revenue",
    "requester": "경영진",
    "question": "2025년 11월 15일부터 2025년 12월 15일까지의 기간 동안, 모든 사용자 세그먼트(country 기준)별로 총 거래액(GMV) 추이와 함께, 첫 구매를 완료한 신규 활성 사용자(Activation) 수를 월별로 분석하고 싶습니다. 이는 현재 시장별 매출 성장과 신규 고객 확보 현황을 종합적으로 파악하는 데 중요합니다.",
    "context": "경영진은 비즈니스의 전반적인 성장 상태를 파악해야 합니다. 특정 기간 동안의 매출뿐만 아니라, 신규 고객의 유입 및 구매 활동도 함께 분석하여 비즈니스의 지속 가능성을 평가합니다.",
    "submission_requirements": "결과는 'country', 'month' (YYYY-MM 형식), 'total_gmv', 'new_activated_users' 컬럼으로 제공합니다. 'total_gmv'는 해당 월의 총 거래액이며, 'new_activated_users'는 해당 월에 첫 구매를 완료한 신규 사용자 수를 의미합니다. 결과는 country 별로, 그리고 month 별로 오름차순 정렬해주세요. 분석 기간은 2025-11-15부터 2025-12-15까지입니다.",
    "answer_sql": "WITH MonthlyOrders AS (\n    SELECT\n        pu.country,\n        DATE_TRUNC('month', po.order_time)::DATE AS order_month,\n        SUM(po.amount) AS monthly_gmv\n    FROM pa_orders po\n    JOIN pa_users pu ON po.user_id = pu.user_id\n    WHERE po.order_time BETWEEN '2025-11-15 00:00:00' AND '2025-12-15 23:59:59'\n    GROUP BY pu.country, DATE_TRUNC('month', po.order_time)\n),\nFirstPurchaseUsers AS (\n    SELECT\n        pu.country,\n        DATE_TRUNC('month', MIN(po.order_time))::DATE AS first_purchase_month,\n        COUNT(DISTINCT po.user_id) AS new_activated_users\n    FROM pa_orders po\n    JOIN pa_users pu ON po.user_id = pu.user_id\n    WHERE pu.signup_at < po.order_time -- 신규 가입 이후 첫 구매\n    AND po.order_time BETWEEN '2025-11-15 00:00:00' AND '2025-12-15 23:59:59'\n    GROUP BY pu.country, DATE_TRUNC('month', MIN(po.order_time))\n)\nSELECT\n    mo.country,\n    mo.order_month AS month,\n    mo.monthly_gmv AS total_gmv,\n    COALESCE(fpu.new_activated_users, 0) AS new_activated_users\nFROM\n    MonthlyOrders mo\nLEFT JOIN\n    FirstPurchaseUsers fpu ON mo.country = fpu.country AND mo.order_month = fpu.first_purchase_month\nWHERE\n    mo.order_month BETWEEN '2025-11-01' AND '2025-12-01' -- 11월과 12월만 분석\nORDER BY\n    mo.country ASC,\n    mo.order_month ASC;",
    "expected_description": "각 국가별로 월별 총 거래액(GMV)과 해당 월에 첫 구매를 완료한 신규 활성 사용자 수를 보여주는 테이블입니다.",
    "expected_columns": [
      "country",
      "month",
      "total_gmv",
      "new_activated_users"
    ],
    "sort_keys": [
      "country ASC",
      "month ASC"
    ],
    "hint": "월별 총 거래액을 계산하는 CTE와, 각 월별 첫 구매를 완료한 신규 사용자를 계산하는 CTE를 각각 만듭니다. 이때, 첫 구매인지 확인하기 위해 signup_at과 order_time을 비교합니다. 두 CTE를 LEFT JOIN하여 최종 결과를 도출하고, COALESCE 함수를 사용하여 신규 활성 사용자가 없는 경우 0으로 표시합니다. 분석 기간을 정확히 필터링해야 합니다.",
    "date": "2026-01-06",
    "set_index": 2,
    "xp_value": 8,
    "expected_result": [],
    "expected_row_count": 0
  }
]