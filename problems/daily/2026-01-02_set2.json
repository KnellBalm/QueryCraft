[
  {
    "problem_id": "2026-01-02_ecommerce_sql_001_set2",
    "difficulty": "easy",
    "topic": "revenue",
    "requester": "마케팅팀",
    "question": "채널별 신규 고객의 첫 구매 금액(AOV)을 파악하고 싶습니다. 각 채널별로 signup_at 날짜가 2025년 11월 1일부터 11월 30일까지인 사용자를 대상으로, 해당 기간 동안 발생한 첫 구매 건에 대한 평균 주문 금액(AOV)을 계산해주세요. 결과는 AOV 기준 내림차순으로 정렬해주세요.",
    "context": "최근 마케팅 캠페인의 효율성을 측정하고, 어떤 채널이 고가치 고객을 유치하는 데 효과적인지 파악하기 위해 신규 고객의 첫 구매 행동을 분석해야 합니다. 이를 통해 향후 마케팅 예산을 효율적으로 배분할 수 있습니다.",
    "submission_requirements": "결과는 'channel', 'average_order_value' 두 개의 컬럼으로 구성되어야 합니다. 'average_order_value'는 소수점 둘째 자리까지 표시하며, 결과는 'average_order_value' 기준 내림차순으로 정렬해주세요.",
    "answer_sql": "WITH first_purchase AS (\n    SELECT\n        po.user_id,\n        po.amount,\n        ROW_NUMBER() OVER (PARTITION BY po.user_id ORDER BY po.order_time) as rn\n    FROM pa_orders po\n    JOIN pa_users pu ON po.user_id = pu.user_id\n    WHERE pu.signup_at BETWEEN '2025-11-01 00:00:00' AND '2025-11-30 23:59:59'\n)\nSELECT\n    pu.channel,\n    AVG(fp.amount) AS average_order_value\nFROM first_purchase fp\nJOIN pa_users pu ON fp.user_id = pu.user_id\nWHERE fp.rn = 1\nGROUP BY pu.channel\nORDER BY average_order_value DESC;",
    "expected_description": "각 마케팅 채널별로 2025년 11월에 가입한 신규 고객의 첫 구매 평균 주문 금액을 나타냅니다.",
    "expected_columns": [
      "channel",
      "average_order_value"
    ],
    "sort_keys": [
      "average_order_value"
    ],
    "hint": "먼저 각 사용자의 첫 구매 건을 식별하기 위해 ROW_NUMBER() 윈도우 함수를 사용하세요. 이후 pa_users 테이블과 조인하여 채널별로 평균 금액을 계산합니다.",
    "date": "2026-01-02",
    "set_index": 2,
    "xp_value": 3,
    "expected_result": [
      {
        "channel": "referral",
        "average_order_value": 25228.69230769231
      },
      {
        "channel": "ad",
        "average_order_value": 24711.485714285714
      },
      {
        "channel": "web",
        "average_order_value": 21945.5
      },
      {
        "channel": "organic",
        "average_order_value": 18692.235294117647
      }
    ],
    "expected_row_count": 4
  },
  {
    "problem_id": "2026-01-02_ecommerce_sql_002_set2",
    "difficulty": "easy",
    "topic": "funnel",
    "requester": "PM팀",
    "question": "2025년 12월 15일 하루 동안 가장 많이 발생한 이벤트 유형 Top 5를 알려주세요. 각 이벤트 유형별 발생 횟수를 기준으로 내림차순으로 정렬해주세요.",
    "context": "당일 발생한 사용자 행동 데이터를 파악하여 서비스 이용 패턴을 이해하고, 특정 이벤트의 급증 또는 급감 원인을 빠르게 파악하기 위함입니다. 이는 실시간 모니터링 및 잠재적 문제점 식별에 중요합니다.",
    "submission_requirements": "결과는 'event_name', 'event_count' 두 개의 컬럼으로 구성되어야 합니다. 'event_count'는 해당 이벤트가 발생한 총 횟수이며, 결과는 'event_count' 기준 내림차순으로 정렬된 상위 5개만 포함해야 합니다.",
    "answer_sql": "SELECT\n    event_name,\n    COUNT(*) AS event_count\nFROM pa_events\nWHERE event_time >= '2025-12-15 00:00:00' AND event_time < '2025-12-16 00:00:00'\nGROUP BY event_name\nORDER BY event_count DESC\nLIMIT 5;",
    "expected_description": "2025년 12월 15일 하루 동안 발생한 이벤트 유형별 발생 횟수를 나타내며, 가장 많이 발생한 이벤트 5가지를 포함합니다.",
    "expected_columns": [
      "event_name",
      "event_count"
    ],
    "sort_keys": [
      "event_count"
    ],
    "hint": "pa_events 테이블에서 원하는 날짜 범위의 데이터를 필터링하고, event_name별로 GROUP BY하여 COUNT(*)로 집계합니다. ORDER BY와 LIMIT를 사용하여 상위 5개를 추출하세요.",
    "date": "2026-01-02",
    "set_index": 2,
    "xp_value": 3,
    "expected_result": [
      {
        "event_name": "view_product",
        "event_count": 5098
      },
      {
        "event_name": "page_view",
        "event_count": 3048
      },
      {
        "event_name": "view_review",
        "event_count": 1720
      },
      {
        "event_name": "search",
        "event_count": 1378
      },
      {
        "event_name": "notification_open",
        "event_count": 592
      }
    ],
    "expected_row_count": 5
  },
  {
    "problem_id": "2026-01-02_ecommerce_sql_003_set2",
    "difficulty": "medium",
    "topic": "funnel",
    "requester": "CX팀",
    "question": "사용자가 'add_to_cart' 이벤트 이후 'begin_checkout' 이벤트를 발생시키지 않고 장바구니에서 이탈한 비율을 계산해주세요. 분석은 2025년 12월 한 달 동안 발생한 세션 기준으로 계산해야 합니다. 'add_to_cart' 이벤트가 발생했지만 'begin_checkout' 이벤트가 발생하지 않은 세션 수를 'total_cart_abandonment_sessions'로, 'add_to_cart' 이벤트가 발생한 총 세션 수를 'total_sessions_with_add_to_cart'로 하여 비율을 계산해주세요.",
    "context": "장바구니 이탈은 잠재적인 매출 손실로 이어지므로, 이탈률을 정확히 파악하여 개선 방안을 모색해야 합니다. 특히 'add_to_cart' 이후 checkout 진입이 없는 세션에 집중하여 이탈 원인을 분석하고자 합니다.",
    "submission_requirements": "결과는 'cart_abandonment_rate' 라는 단일 컬럼으로 구성되어야 하며, 소수점 넷째 자리까지 표시되어야 합니다. 이탈률은 (장바구니 이탈 세션 수 / 장바구니에 상품을 담은 총 세션 수) * 100 으로 계산합니다.",
    "answer_sql": "WITH cart_events AS (\n    SELECT\n        session_id,\n        event_name,\n        ROW_NUMBER() OVER (PARTITION BY session_id ORDER BY event_time) as rn_event_order\n    FROM pa_events\n    WHERE event_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n    AND event_name IN ('add_to_cart', 'begin_checkout')\n),\nadd_to_cart_sessions AS (\n    SELECT DISTINCT session_id\n    FROM cart_events\n    WHERE event_name = 'add_to_cart'\n),\ncheckout_started_sessions AS (\n    SELECT DISTINCT session_id\n    FROM cart_events\n    WHERE event_name = 'begin_checkout'\n),\ncart_abandonment_sessions AS (\n    SELECT COUNT(DISTINCT ats.session_id)\n    FROM add_to_cart_sessions ats\n    LEFT JOIN checkout_started_sessions css ON ats.session_id = css.session_id\n    WHERE css.session_id IS NULL\n),\ntotal_sessions AS (\n    SELECT COUNT(DISTINCT session_id) FROM add_to_cart_sessions\n)\nSELECT\n    CASE\n        WHEN (SELECT * FROM total_sessions) = 0 THEN 0.0000\n        ELSE ROUND((CAST((SELECT * FROM cart_abandonment_sessions) AS NUMERIC) / (SELECT * FROM total_sessions)) * 100, 4)\n    END AS cart_abandonment_rate;",
    "expected_description": "2025년 12월 한 달 동안 'add_to_cart' 이벤트가 발생한 세션 중 'begin_checkout' 이벤트가 발생하지 않아 장바구니에서 이탈한 세션의 비율을 나타냅니다.",
    "expected_columns": [
      "cart_abandonment_rate"
    ],
    "sort_keys": [],
    "hint": "각 세션별로 'add_to_cart'와 'begin_checkout' 이벤트 발생 여부를 파악해야 합니다. CTE(Common Table Expression)를 활용하여 'add_to_cart'가 발생한 세션과 'begin_checkout'이 발생한 세션을 각각 구분한 후, 차집합을 이용해 이탈 세션을 식별합니다. division by zero를 방지하기 위해 NULLIF 또는 CASE 문을 사용하세요.",
    "date": "2026-01-02",
    "set_index": 2,
    "xp_value": 5,
    "expected_result": [
      {
        "cart_abandonment_rate": 81.83
      }
    ],
    "expected_row_count": 1
  },
  {
    "problem_id": "2026-01-02_ecommerce_sql_004_set2",
    "difficulty": "medium",
    "topic": "retention",
    "requester": "그로스팀",
    "question": "2025년 11월에 첫 구매를 완료한 고객 중 2025년 12월에도 재구매를 한 고객의 비율(Repeat Purchase Rate)을 계산해주세요. 재구매율은 (11월 첫 구매자 중 12월 재구매자 수 / 11월 첫 구매자 수) * 100 으로 계산합니다. 결과는 'repeat_purchase_rate'라는 컬럼명으로 반환해주세요.",
    "context": "고객 유지율은 비즈니스의 장기적인 성장에 매우 중요한 지표입니다. 11월에 신규 고객을 얼마나 잘 유지하여 재구매로 이어지게 하는지 파악함으로써 고객 충성도 및 마케팅 전략의 효과를 평가할 수 있습니다.",
    "submission_requirements": "결과는 'repeat_purchase_rate'라는 단일 컬럼으로 구성되어야 하며, 소수점 넷째 자리까지 표시되어야 합니다. 재구매율은 0%에서 100% 사이의 값으로 계산됩니다.",
    "answer_sql": "WITH november_first_buyers AS (\n    SELECT\n        user_id,\n        MIN(order_time) as first_order_time\n    FROM pa_orders\n    WHERE order_time BETWEEN '2025-11-01 00:00:00' AND '2025-11-30 23:59:59'\n    GROUP BY user_id\n),\ndecember_repeat_buyers AS (\n    SELECT\n        po.user_id\n    FROM pa_orders po\n    JOIN november_first_buyers nfb ON po.user_id = nfb.user_id\n    WHERE po.order_time BETWEEN '2025-12-01 00:00:00' AND '2025-12-31 23:59:59'\n    AND po.order_time > nfb.first_order_time -- 11월 첫 구매 이후 12월 구매 건만 고려\n    GROUP BY po.user_id\n),\nfirst_buyers_count AS (\n    SELECT COUNT(*) AS total_first_buyers FROM november_first_buyers\n),\nrepeat_buyers_count AS (\n    SELECT COUNT(*) AS total_repeat_buyers FROM december_repeat_buyers\n)\nSELECT\n    CASE\n        WHEN (SELECT total_first_buyers FROM first_buyers_count) = 0 THEN 0.0000\n        ELSE ROUND((CAST((SELECT total_repeat_buyers FROM repeat_buyers_count) AS NUMERIC) / (SELECT total_first_buyers FROM first_buyers_count)) * 100, 4)\n    END AS repeat_purchase_rate;",
    "expected_description": "2025년 11월에 첫 구매를 한 고객 중 2025년 12월에 재구매를 한 고객의 비율을 백분율로 나타냅니다.",
    "expected_columns": [
      "repeat_purchase_rate"
    ],
    "sort_keys": [],
    "hint": "먼저 11월에 첫 구매를 한 고객 목록을 추출하는 CTE를 만듭니다. 이후 12월에 구매한 기록이 있는 고객 중 11월 첫 구매자 명단에 있는 고객을 찾아 재구매자 수를 계산합니다. division by zero를 방지하기 위해 CASE 문을 사용하세요.",
    "date": "2026-01-02",
    "set_index": 2,
    "xp_value": 5,
    "expected_result": [
      {
        "repeat_purchase_rate": 0.0
      }
    ],
    "expected_row_count": 1
  },
  {
    "problem_id": "2026-01-02_ecommerce_sql_005_set2",
    "difficulty": "hard",
    "topic": "funnel",
    "requester": "그로스팀",
    "question": "쿠폰 사용(apply_coupon)이 실제 구매(purchase) 전환에 미치는 영향을 분석하고 싶습니다. 2025년 11월 15일부터 12월 15일까지의 기간 동안, 'apply_coupon' 이벤트 후에 'purchase' 이벤트를 발생시킨 세션의 비율과, 'apply_coupon' 이벤트는 발생했지만 'purchase' 이벤트는 발생하지 않은 세션의 비율을 각각 계산해주세요. 결과 컬럼은 'coupon_applied_and_purchased_rate'와 'coupon_applied_but_not_purchased_rate'로 해주세요.",
    "context": "쿠폰 프로모션은 매출 증대에 기여하지만, 실제로 쿠폰이 구매 전환을 얼마나 유도하는지 정확히 파악하는 것이 중요합니다. 쿠폰 적용 후 이탈하는 고객 세션과 성공적으로 구매하는 세션을 분리하여 분석함으로써 쿠폰 전략의 효율성을 개선할 수 있습니다.",
    "submission_requirements": "결과는 'coupon_applied_and_purchased_rate'와 'coupon_applied_but_not_purchased_rate' 두 개의 컬럼으로 구성되어야 합니다. 각 비율은 소수점 넷째 자리까지 표시됩니다. 두 비율 모두 'apply_coupon' 이벤트가 발생한 전체 세션 수를 기준으로 계산합니다. 정렬은 필요 없습니다.",
    "answer_sql": "WITH session_events AS (\n    SELECT\n        session_id,\n        event_time,\n        event_name,\n        ROW_NUMBER() OVER (PARTITION BY session_id ORDER BY event_time) as rn\n    FROM pa_events\n    WHERE event_time BETWEEN '2025-11-15 00:00:00' AND '2025-12-15 23:59:59'\n    AND event_name IN ('apply_coupon', 'purchase')\n),\ncoupon_applied_sessions AS (\n    SELECT DISTINCT session_id\n    FROM session_events\n    WHERE event_name = 'apply_coupon'\n),\npurchase_after_coupon_sessions AS (\n    SELECT DISTINCT se.session_id\n    FROM session_events se\n    JOIN coupon_applied_sessions cas ON se.session_id = cas.session_id\n    WHERE se.event_name = 'purchase'\n    AND se.event_time > (SELECT MIN(event_time) FROM session_events WHERE session_id = se.session_id AND event_name = 'apply_coupon')\n),\ncoupon_applied_total AS (\n    SELECT COUNT(DISTINCT session_id) FROM coupon_applied_sessions\n),\npurchased_with_coupon AS (\n    SELECT COUNT(DISTINCT session_id) FROM purchase_after_coupon_sessions\n),\nnot_purchased_with_coupon AS (\n    SELECT \n        (SELECT COUNT(DISTINCT session_id) FROM coupon_applied_sessions) - \n        (SELECT COUNT(DISTINCT session_id) FROM purchase_after_coupon_sessions)\n)\nSELECT\n    CASE\n        WHEN (SELECT COUNT(DISTINCT session_id) FROM coupon_applied_sessions) = 0 THEN 0.0000\n        ELSE ROUND((CAST((SELECT COUNT(DISTINCT session_id) FROM purchase_after_coupon_sessions) AS NUMERIC) * 100.0) / (SELECT COUNT(DISTINCT session_id) FROM coupon_applied_sessions), 4)\n    END AS coupon_applied_and_purchased_rate,\n    CASE\n        WHEN (SELECT COUNT(DISTINCT session_id) FROM coupon_applied_sessions) = 0 THEN 0.0000\n        ELSE ROUND((CAST((SELECT * FROM not_purchased_with_coupon) AS NUMERIC) * 100.0) / (SELECT COUNT(DISTINCT session_id) FROM coupon_applied_sessions), 4)\n    END AS coupon_applied_but_not_purchased_rate;",
    "expected_description": "2025년 11월 15일부터 12월 15일까지 쿠폰이 적용된 세션 중, 성공적으로 구매로 이어진 세션의 비율과, 쿠폰은 적용되었으나 구매로 이어지지 않은 세션의 비율을 나타냅니다.",
    "expected_columns": [
      "coupon_applied_and_purchased_rate",
      "coupon_applied_but_not_purchased_rate"
    ],
    "sort_keys": [],
    "hint": "먼저 'apply_coupon'과 'purchase' 이벤트가 발생한 세션을 구분해야 합니다. 각 세션 내에서 'apply_coupon' 이벤트 이후에 'purchase' 이벤트가 발생했는지 확인해야 합니다. 윈도우 함수와 CTE를 활용하여 각 세션의 이벤트 순서를 파악하고, 'apply_coupon' 이벤트가 발생한 총 세션 수를 기준으로 비율을 계산합니다. division by zero 방지를 위해 CASE 문을 사용하세요.",
    "date": "2026-01-02",
    "set_index": 2,
    "xp_value": 8,
    "expected_result": [
      {
        "coupon_applied_and_purchased_rate": 1.3049,
        "coupon_applied_but_not_purchased_rate": 98.6951
      }
    ],
    "expected_row_count": 1
  },
  {
    "problem_id": "2026-01-02_ecommerce_sql_006_set2",
    "difficulty": "hard",
    "topic": "revenue",
    "requester": "경영진",
    "question": "2025년 10월 30일부터 12월 29일까지, 일별 총 매출액(GMV) 추이를 계산하고, 해당 일에 첫 구매를 한 신규 고객의 매출액 비중을 계산해주세요. 결과는 'date', 'daily_gmv', 'new_customer_gmv_percentage' 컬럼으로 구성되어야 합니다. 'new_customer_gmv_percentage'는 해당 일의 총 매출액 중 첫 구매자 매출액이 차지하는 비율(%)입니다.",
    "context": "전체 매출 추이와 함께 신규 고객이 전체 매출에 얼마나 기여하는지를 파악하는 것은 비즈니스 성장의 동력을 이해하는 데 필수적입니다. 이를 통해 신규 고객 확보 전략의 성과를 평가하고 향후 성장 계획을 수립할 수 있습니다.",
    "submission_requirements": "결과는 'date', 'daily_gmv', 'new_customer_gmv_percentage' 세 개의 컬럼으로 구성되어야 합니다. 'date'는 YYYY-MM-DD 형식이어야 하며, 'daily_gmv'는 해당 일의 총 매출액, 'new_customer_gmv_percentage'는 소수점 둘째 자리까지 표시된 백분율입니다. 결과는 'date' 기준 오름차순으로 정렬해주세요.",
    "answer_sql": "WITH daily_orders AS (\n    SELECT\n        DATE(order_time) as order_date,\n        order_id,\n        user_id,\n        amount\n    FROM pa_orders\n    WHERE order_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n),\nfirst_purchase_users AS (\n    SELECT\n        user_id,\n        MIN(order_time) as first_order_time\n    FROM pa_orders\n    WHERE order_time BETWEEN '2025-10-30 00:00:00' AND '2025-12-29 23:59:59'\n    GROUP BY user_id\n),\ndaily_gmv_data AS (\n    SELECT\n        order_date,\n        SUM(amount) as daily_gmv,\n        SUM(CASE WHEN DATE(fpu.first_order_time) = do.order_date THEN do.amount ELSE 0 END) as new_customer_gmv\n    FROM daily_orders do\n    LEFT JOIN first_purchase_users fpu ON do.user_id = fpu.user_id\n    GROUP BY order_date\n)\nSELECT\n    order_date::DATE as date,\n    daily_gmv,\n    CASE\n        WHEN daily_gmv = 0 THEN 0.00\n        ELSE ROUND((CAST(new_customer_gmv AS NUMERIC) * 100.0) / daily_gmv, 2)\n    END as new_customer_gmv_percentage\nFROM daily_gmv_data\nORDER BY date ASC;",
    "expected_description": "2025년 10월 30일부터 12월 29일까지 각 날짜별 총 매출액(GMV)과, 해당 일에 첫 구매를 완료한 신규 고객으로부터 발생한 매출액의 비율을 나타냅니다.",
    "expected_columns": [
      "date",
      "daily_gmv",
      "new_customer_gmv_percentage"
    ],
    "sort_keys": [
      "date"
    ],
    "hint": "먼저 전체 주문 데이터를 날짜별로 집계하여 일별 총 매출액(GMV)을 계산합니다. 동시에 각 사용자의 첫 구매 날짜를 식별하는 CTE를 만듭니다. 이후 이 두 정보를 결합하여 각 날짜별로 신규 고객의 매출액 비중을 계산합니다. CASE 문을 사용하여 division by zero를 방지하고, DATE() 함수로 날짜 형식만 추출합니다.",
    "date": "2026-01-02",
    "set_index": 2,
    "xp_value": 8,
    "expected_result": [],
    "expected_row_count": 0
  }
]